##### 前言

[github参考](https://github.com/iostalks/Algorithms)

##### 一 数组

- 数组特点：

  内存连续，线性表结构

- 数组的插入操作

  平均时间复杂度 O(n)

  如果无序，则可以时间复杂度将为O(1)

- 数组删除操作

  JVM 标记清除垃圾回收算法的核心思想

  先将要删除的标记，然后统一删除

- 实现一个支持动态扩容的数组

  ```java
  // minCapacity 数组实际的新长度 
  private void grow(int minCapacity) {
  	 int oldCapacity = elementData.length;
          int newCapacity = oldCapacity + (oldCapacity >> 1);  //数组原长度*1.5
          if (newCapacity - minCapacity < 0)
              newCapacity = minCapacity;
          if (newCapacity - MAX_ARRAY_SIZE > 0)
              newCapacity = hugeCapacity(minCapacity);
          // minCapacity is usually close to size, so this is a win:
          elementData = Arrays.copyOf(elementData, newCapacity);
   }
   private static int hugeCapacity(int minCapacity) {
          if (minCapacity < 0) // overflow 溢出
              throw new OutOfMemoryError();
          return (minCapacity > MAX_ARRAY_SIZE) ?
              Integer.MAX_VALUE :
              MAX_ARRAY_SIZE;
   }
  
  ```

  

- 实现一个大小固定的有序数组，支持动态增删改查

  [简书参考](https://www.jianshu.com/p/3a49875ce580)

  ---

  ###### LeetCode

- 实现两个数组合并为一个有序数组

  [leetcode 88号问题](https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-shu-zu-by-greatedistance/)

- 两数之和

  [leetcode 1号问题](https://leetcode-cn.com/problems/two-sum/)

  最简洁做法 hashMap一次遍历

```java
//使用hashMap 两次遍历
/*
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
*/
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] indexs=new int[2];
     	Map<Integer,Integer> map=new HashMap();
        for(int i=0;i<nums.length;i++){
            map.put(nums[i],i);
        }
        for(int j=0;j<nums.length;j++){
            int tmp=target-nums[j];
            if(map.containsKey(tmp)&& map.get(tmp)!=j){
                return new int{j,map.get(tmp)};
            }
        }       
    }
}

  
```

- 三数之和

  [leetcode 15号题](https://leetcode-cn.com/problems/3sum/solution/three-sum-ti-jie-by-wonderful611/)
  
  - 最优解 使用对撞指针，同时 在pre_num 和 next_num中去掉重复元素
  
  ```java
  class Solution {
       public List<List<Integer>> threeSum(int[] nums) {
            List<List<Integer>> res=new ArrayList<>();
          Arrays.sort(nums);
          int index=0;
          while (index<nums.length){
              if(nums[index]>0)
                  break;
              int bindex=index+1;
              int cindex=nums.length-1;
                  while (bindex<cindex){
                  int tmp=nums[index]+nums[bindex]+nums[cindex];
                      if(tmp==0) {
                          res.add(Arrays.asList(nums[index],nums[bindex],nums[cindex]));
                          bindex=next_index(bindex,nums);
                          cindex=pre_index(cindex,nums);
                      }else if(tmp>0){
                          cindex=pre_index(cindex,nums);
                      }else {
                         bindex= next_index(bindex,nums);
                      }
                  }
                  index=next_index(index,nums);
              }
          return res;
      }
       private int next_index(int index,int[] nums){
          for (int i=index+1;i<nums.length;i++){
              if(nums[i]!=nums[index]){
                  return i;
              }
          }
          return nums.length;
      }
      private int pre_index(int index,int[] nums){
          for (int i=index-1;i>0;i--){
              if(nums[i]!=nums[index]){
                  return i;
              }
          }
          return -1;
      }
      
  }
  ```
  
  
  
  - 使用set去除重复元素，和对撞指针
  
    
  
  ```java
  class Solution {
       public List<List<Integer>> threeSum(int[] nums) {
          Set<List<Integer>> set=new HashSet<>();
          Arrays.sort(nums);
          for (int i=0;i<nums.length-1;i++){
           int start=i+1;
           int end=nums.length-1;
           while (start<end){
               if(nums[i]+nums[start]+nums[end]==0){
                   set.add(Arrays.asList(nums[i],nums[start],nums[end]));
                   start++;
                   end--;
               }else if(nums[i]+nums[start]+nums[end]<0){
                   start++;
               }else {
                   end--;
               }
           }
          }
          return new ArrayList<>(set);
      }
      
  }
  ```
  
  